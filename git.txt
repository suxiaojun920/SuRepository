Git:
  1:安装Git
  2:设置用户名信息
  	global 是全局配置文件 ,文件的位置在用户主目录下的.gitconfig文件 
	system 是系统配置文件,文件的位置在etc下的gitconfig 
	local是版本库配置文件,文件位置在.git/config 
     $ git config --global user.name 'suxiaojun'
     $ git config --blobal user.email 'suxie-1@163.com'

  3:删除用户信息
  	 $ git config --unset --global user.name
	 $ git config --unset --global user.email

  4:查看用户配置信息
     $ git config --list

  5:在当前的目录下创建目录
   mkdir 目录名称

  6:改变当前目录
   cd 目录 (cd D:/)

  7:查看当前目录路径
   pwd

  8:查看当前目录下的子目录和文件
   ls

  9:把文件添加到仓库
   $ git add readme.txt

  10:把修改提交到仓库
   $ git commit -m '消息'

  11:修改文本文件
     vim maven.txt
     按i插入数据(修改文件)
     按ESC 结束编辑 Shift+ZZ 保存退出
     cat maven.txt 查看文件
     按了ESC后再输入冒号，在输入命令时，直接输入"q" 不正常退出(没有修改文件)
     先按ESC，再输入冒号，在输入命令时，直接输入"q!" 不保存退出
     先按ESC，再按冒号，在输入命令时，直接输入"!" 强制退出

  commit可以一次提交很多文件，所以你可以多次add不同的文件

  12:查看当前仓库的状态
     git status

    # On branch master
	# Changes to be committed:  (已经在stage区, 等待添加到HEAD中的文件)
	# (use "git reset HEAD <file>..." to unstage)
	#
	#modified: hello.py
	#
	# Changes not staged for commit: (有修改, 但是没有被添加到stage区的文件)
	# (use "git add <file>..." to update what will be committed)
	# (use "git checkout -- <file>..." to discard changes in working directory)
	#
	#modified: main.py
	#
	# Untracked files:(没有tracked过的文件, 即从没有add过的文件)
	# (use "git add <file>..." to include in what will be committed)
	#
	#hello.pyc原文出自【易百教程】，商业转载请联系作者获得授权，非商业请保留原文链接：https://www.yiibai.com/git/git_status.html

  13:查看修改的详细信息
     git diff

  14:增加修改
     git add maven.txt

  15:提交修改
     git commit -m "修改信息"

  16:查看文件修改历史
     查看详细信息
     git log
     查看详细信息 一个版本显示一行
     git log --pretty=oneline


  17:回退到上一个版本(上一个版本是HEAD^ 上上个版本是HEAD^^ 回退100级 需要100个^ 所以可以写成 HEAD~100)
     $ git reset --hard HEAD^
     也可以指定回退的版本号(回退后回退跳过的版本git log看不见了 可以再以前的log上查询)
     $ git reset --hard 1094a(可以利用git log 查看)

  18:查看历史版本
    用git reflog查看命令历史，以便确定要回到未来的哪个版本

    //查看文件内容 
    cat maven.txt 

    Git 三个区 (工作区(Untracked(未跟踪)-->暂存区(Changes not staged for commit 改变暂存区未提交)-->版本库)

    1:git diff 不加参数即默认比较工作区与暂存区
    2:git diff --cached [文件] 比较暂存区与最新本地版本库（本地库中最近一次commit的内容）
    3:git diff HEAD [文件] 比较工作区与最新本地版本库
    4:git diff commit-id [文件]  比较工作区与指定commit-id的差异
    5:git diff --cached [commit-id] [文件] 比较暂存区与指定commit-id的差异
    6:git diff [commit-id] [commit-id] 比较两个commit-id之间的差异

   Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件

   git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别

   git checkout -- file可以丢弃工作区的修改(工作区修改了 还没有git add ) git checkout -- git.txt 恢复暂存区版本到工作区

   命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：

	一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；

	一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态

   git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令

   命令git reset HEAD <file>可以把暂存区的修改撤销掉（unstage），重新放回工作区

   git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本

   	场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。

	场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD <file>，就回到了场景1，第二步按场景1操作。

	场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退 git reset --hard commitId，不过前提是没有推送到远程库

	删除工作区文件
	 $ rm test.txt

	一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit

	一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：

	$ git checkout -- test.txt


   生成远程仓库的key

   查看是否存在.ssh
   cd ~/.ssh 

   创建文件夹
   mkdir .ssh

   自动在.ssh目录下生成id_rsa以及id_rsa_pub两个文件
   $ ssh-keygen -t rsa -C "youremail@example.com"

   登陆GitHub，打开“Account settings”，“SSH Keys”页面：

   然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容
   点“Add Key”，你就应该看到已经添加的Key


   登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库
   在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库
   目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。

	现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：

	//添加远程库 git remote add 远程库名称 远程库地址
	$ git remote add origin git@github.com:michaelliao/learngit.git
	请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。

	添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库

	把本地版本库的内容推送到远程服务器
	$ git push -u origin master

	//查看当前所有的远程库
	$ git remote

	//列出详细信息，在每一个名字后面列出其远程url
	$ git remote -v

	//查看指定的远程库
	$ git remote show origin

	//克隆远程库
	$ git clone git@github.com:michaelliao/gitskills.git

	//创建分支
	git checkout -b 分支名称(加上-b 相当于两条命令 git branch dev(创建分支dev)   git checkout dev(切换分支dev))

	//查看分支
	git branch
	* master
	  dev

	 git checkout master 切换分支

	分支名称前面有*号 的表示当前的分支

	//合并分支(以下命令是把dev分支合并到当前分支(当前分支切换至master) 把dev的修改合并到master)
	git merge dev

	注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快

	//删除分支(dev)
	git branch -d dev

	//分支合并冲突
	1:git checkout -b dev(切换到dev分支)
    2:修改内容 例如增加一行(dev 分支增加内容)
    3:dev 分支上加入暂存区(git add git.txt)
    4:dev 分支上提交到版本库(git commit -m "dev分支提交")

    5:切换到master分支(git checkout master)
    6:修改内容 例如增加一行(master 分支增加内容)
    7:master 分支上加入暂存区(git add git.txt)
    8:master 分支上提交到版本库(git commit -m "master分支提交")
    //当前分支保持master(因为master分支是主分支 肯定是把其他分支合并到master分支)
    //把dev分支合并到master分支
    9:git merge dev (这个时候会报错，因为两个分支上存在修改了同一个文件)

    打开文件会出现以下内容
    <<<<<<< HEAD 当前分支的内容  ====== 分隔符(=====前后是两个版本不同的地方) >>>>>>> dev 其他分支
    <<<<<<< HEAD
	Creating a new branch is quick & simple.
	=======
	Creating a new branch is quick AND simple.
	>>>>>>> dev

	这个时候把冲突的地方手动修改了
	1:保留两个分支不同的地方
	Creating a new branch is quick & simple.
	Creating a new branch is quick AND simple.
	2:或者保留任意一个分支的内容
	Creating a new branch is quick & simple.

	10:然后在主分支master上add 和 commit
	  git add git.txt
	  git commit -m "master合并"

	这个时候master分支就是解决完冲突的版本  dev分支还是原始dev分支的内容
	可以不要用去管dev分支了(也可以删除dev分支(因为dev分支合并完成就没有存在的必要了))

	通常在合并分支的时候如果dev修改了内容 add 和 commit成功后 但是切换到master分支没有做任何改动那么合并时
	会使用Fast forward模式 就是让master直接指向dev(两个分支指向同一个时间点)

	但是如果切换到master分支后master分支也修改了和dev分支相同的文件那么在合并的时候就会出现冲突，需手动解决
	
	通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。

	如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。
	
	1:git checkout -b dev(创建并切换到dev分支)
	2:修改文件(dev分支在git.txt 添加内容)
	3:git add git.txt
	4:git commit -m "修改git.txt(dev)"

	5:git checout master(切换到master分支)
	注意这个地方master没有修改git.txt内容 直接合并
	如果使用 git merge dev (git会默认使用Fast forward模式 这样合并完成如果删除dev分支 那么dev分支的信息就丢失了)

	所以可以禁用Fast forward模式

	git merge --no-ff-m "合并消息" dev(被合并的分支名称) 其中--no-ff(参数表示禁用Fast forward模式)

	$ git merge --no-ff -m "merge with no-ff" dev
	Merge made by the 'recursive' strategy.
	 readme.txt | 1 +
	 1 file changed, 1 insertion(+)

	因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。

	合并后，我们用git log看看分支历史：

	$ git log --graph --pretty=oneline --abbrev-commit
	*   e1e9c68 (HEAD -> master) merge with no-ff
	|\  
	| * f52c633 (dev) add merge
	|/  
	*   cf810e4 conflict fixed
	...
	可以看到，不使用Fast forward模式 master 和 dev 指向是不一样的地方(Fast forward 模式合并 master和dev指向同一个地方)

	合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并

	场景
	1:目前正在dev上工作，但是现在有一个bug分配下来，但是有不能提交现在的工作，又必须去修改bug
	那么这个时候就可以现在暂时保存dev上的工作(不是add和commit) 就是保存目前的工作
	$ git status
	On branch dev
	Changes to be committed:
	  (use "git reset HEAD <file>..." to unstage)

		new file:   hello.py

	Changes not staged for commit:
	  (use "git add <file>..." to update what will be committed)
	  (use "git checkout -- <file>..." to discard changes in working directory)

		modified:   readme.txt

	从目前的status来看有一个新文件hello.py 在工作区没有提交  还有一个readme.txt 在暂存区未commit

	但是目前不能提交，又必须去其他分支操作，所以需要把当前的状态保存

	$ git stash
	Saved working directory and index state WIP on master: 7eebb00 bug管理

	这个时候查看git status 是干净的
	$ git status
	On branch master
	Your branch is ahead of 'origin/master' by 9 commits.
	  (use "git push" to publish your local commits)

	nothing to commit, working tree clean

	然后切换到其他分支器修改
	修改完add以及commit

	查看status 这个时候应该是干净的
	$ git status
	On branch master
	Your branch is ahead of 'origin/master' by 9 commits.
	  (use "git push" to publish your local commits)

	nothing to commit, working tree clean

	使用 git stash list 查看当前保存的bug 显示当前存在一个bug管理
	$ git stash list
	stash@{0}: WIP on master: 7eebb00 bug管理

	工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：

	一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；

	$ git stash apply

	$git stash drop

	另一种方式是用git stash pop，恢复的同时把stash内容也删了

	$ git stash pop

	你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令：

	$ git stash apply stash@{0}


	软件开发中，总有无穷无尽的新的功能要不断添加进来。

	添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。

	现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。

	于是准备开发：

	$ git checkout -b feature-vulcan
	Switched to a new branch 'feature-vulcan'

	5分钟后，开发完毕：

	$ git add vulcan.py

	$ git status
	On branch feature-vulcan
	Changes to be committed:
	  (use "git reset HEAD <file>..." to unstage)

		new file:   vulcan.py

	$ git commit -m "add feature vulcan"
	[feature-vulcan 287773e] add feature vulcan
	 1 file changed, 2 insertions(+)
	 create mode 100644 vulcan.py
	 
	切回dev，准备合并：

	$ git checkout dev
	一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。

	但是！

	就在此时，接到上级命令，因经费不足，新功能必须取消！

	虽然白干了，但是这个包含机密资料的分支还是必须就地销毁：

	$ git branch -d feature-vulcan
	error: The branch 'feature-vulcan' is not fully merged.
	If you are sure you want to delete it, run 'git branch -D feature-vulcan'.
	销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。。

	现在我们强行删除：

	$ git branch -D feature-vulcan
	Deleted branch feature-vulcan (was 287773e).
	终于删除成功！




	

   
